



# 策略模式

假设现在需要你开发一个获取用户列表的方法getUser，要求是可以对用户列表进行排序，排序方式要支持姓名、创建时间和所属部门的升降排序，现在先花一分钟时间思考下，如何实现这个getUser方法呢，getUser方法的参数是什么？

从需求来看，getUser应该需要两个参数：排序字段sortKey(name|createTime|department)、排序方式sortDirection(asc|desc)，我们先按这个思路实现下。

```javascript
function getUser(sortKey, sortDirection){
    //忽略通过请求获取用户数据相关代码
    let users = [
        {name: '用户1', createTime: '2023-10-1', department: '前端部'},
        {name: '用户2', createTime: '2023-10-2', department: '后端部'},
    ];
    
    switch (sortKey){
        case 'name':
            if(sortDirection === 'asc'){
                //按照名称升序排序
            }else{
                //按照名称降序排序
            }
            break;
        case 'createTime':
            if(sortDirection === 'asc'){
                //按照创建时间升序排序
            }else{
                //按照创建时间降序排序
            }
            break;
        case 'department':
            if(sortDirection === 'asc'){
                //按照部门升序排序
            }else{
                //按照部门降序排序
            }
            break;
    }
    return users;
}

getUser('name', 'asc'); //按照名称升序获取用户
getUser('createTime', 'desc'); //按照创建时间降序获取用户
```

这样实现可以满足需求，但是也存在一些可读性和可维护性方面的问题

首先是这样的代码可读性较差，体现在两个方面，第一个点是getUser函数中充斥着大量的分支语句(switch、if)，每个分支都会增加阅读的成本，分支越多，嵌套分支越深，理解起来就越困难；第二个点是排序部分所占的代码比重在getUser函数中过高，有点头轻脚重的感觉，代码不够结构化。

在可维护性方面，后续如果要增加一些新的排序方式，你就必须要先理解getUser方法的实现原理，然后再修改getUser方法中关于排序的实现，别小看这个修改，虽然你只是想修改排序部分，但是难保不会引入新的bug，毕竟你是在修改同一个函数。

能不能将排序实现抽出去呢？不同的排序可以看成不同的算法或者策略，我们在调用getUser方法时传递想要的排序策略不就可以了吗，按照这个思路修改下：

```javascript
const nameAscStrategy = function (users){  }; //按照名称升序排序
const nameDescStrategy = function (users){  }; //按照名称降序排序
const createTimeAscStrategy = function (users){  }; //按照创建时间升序排序
const createTimeDescStrategy = function (users){  }; //按照创建时间降序排序
const departmentAscStrategy = function (users){  }; //按照部门升序排序
const departmentDescStrategy = function (users){  }; //按照部门降序排序


function getUser(sortStrategy){
    //忽略通过请求获取用户数据相关代码
    let users = [
        {name: '用户1', createTime: '2023-10-1', department: '前端部'},
        {name: '用户2', createTime: '2023-10-2', department: '后端部'},
    ];
    
    return sortStrategy(users);
}

getUser(nameAscStrategy); //按照名称升序获取用户
getUser(createTimeDescStrategy); //按照创建时间降序获取用户
```

现在我们再来看看getUser方法的实现，是不是瞬间清爽了很多！里面不再有让人讨厌的分支语句了，可以说非常地优雅~~后续再有新的排序方式，也不需要修改getUser方法，只需要创建一个新的排序策略即可。

为了让策略更加高内聚，我们可以将所有策略集中放到一个对象下。

```javascript
const SORT_STRATEGY = {
    nameAsc: function (users){},
    nameDesc: function (users){},
    createTimeAsc: function (users){},
    createTimeDesc: function (users){},
    departmentAsc: function (users){},
    departmentDesc: function (users){}
}
function getUser(sortStrategy){
    //忽略通过请求获取用户数据相关代码
    let users = [
        {name: '用户1', createTime: '2023-10-1', department: '前端部'},
        {name: '用户2', createTime: '2023-10-2', department: '后端部'},
    ];

    return sortStrategy(users);
}

getUser(SORT_STRATEGY.nameAsc); //按照名称升序获取用户
getUser(SORT_STRATEGY.createTimeDesc); //按照创建时间降序获取用户

```

上述这种优化方式，就是一种策略模式，接下来我们看下策略模式的定义。

## 策略模式定义

> 策略模式（Strategy Pattern）允许在**运行时**根据不同的情况选择不同的算法或策略。该模式将算法或策略封装起来，使得它们可以**相互替换**，此模式可以让算法的变化**隔离于**使用算法的客户之外。

在这个定义中，我们重点关注几个关键词：

- 运行时：运行时意味着可以动态替换策略，比如上述getUser方法，你可以根据情况使用不同的策略，而不是提前固定好的。

```javascript
getUser(SORT_STRATEGY[sortMethod])
```

- 相互替换：多个策略遵循相同的接口，如果策略是一种类，那就有相同的属性和方法；如果策略是个函数，那么就有相同的形参和返回值。

- 隔离变化：策略模式的目的就是隔离算法的变化，将变化的算法抽取到策略中，将不变的部分留在调用策略的客户中。

在策略模式中，通常会定义一个抽象策略接口，所有具体策略类都实现该接口。客户端通过调用策略接口的方法来执行具体的算法。在运行时，可以根据需要动态地切换不同的策略，而不需要修改客户端的代码。

在前端实际开发中，可能很少用到接口，我们可以理解为将策略抽取到一个策略对象当中，每个策略函数遵循同样的参数和返回值规范。这种规范，就可以理解为后端的接口interface。

## 策略模式示例

策略模式的应用很广泛，比如咱们经常用的数组的sort、filter方法等，是不是都把排序策略和过滤策略抽象出来交给用户自行实现，通过这种方式大大提高了数组方法的适用场景。

为了加深对策略模式的理解，我们再举两个示例。

假设现在需要你实现一个搜索功能，要求是要将搜索结果进行缓存，以便于后续快速返回。

先来分析下这个需求，需求中提到了缓存，那使用何种缓存方式呢，内存、localStorage、sessionStorage还是IndexedDB，需求中没有明确说，假设都要支持，那如何设计呢？

我们可以将缓存方式设计成为一种策略，在搜索功能中配置某一种策略，这样即可轻松应对需求变化。

前面我们提到了，策略模式要求每个策略遵循同样的接口，作为缓存策略，我们很容易想到，每个策略应该至少包含以下几个方法：
```typescript
interface CacheStrategy {
    getCache(key: string): any | undefined;
    setCache(key: string, data: any): void;
    has(key: string): boolean;
}
```

接下来我们使用localStorage来实现这个接口

```typescript
class LocalStorageCacheStrategy implements CacheStrategy {
  getCache(key: string): any | undefined {
    const data = localStorage.getItem(key);
    if (data) {
      return JSON.parse(data);
    }
    return undefined;
  }

  setCache(key: string, data: any): void {
    localStorage.setItem(key, JSON.stringify(data));
  }

  has(key: string): boolean {
    return localStorage.getItem(key) !== null;
  }
}
```

通过内存进行存储的策略实现：
```typescript
class MemoryCacheStrategy implements CacheStrategy {
  private cache: { [key: string]: any } = {};

  getCache(key: string): any | undefined {
    return this.cache[key];
  }

  setCache(key: string, data: any): void {
    this.cache[key] = data;
  }

  has(key: string): boolean {
    return key in this.cache;
  }
}
```

接下来实现一个搜索类，在搜索类构造函数中接收一个存储策略，在搜索时调用先调用存储策略的has方法，看看搜索的关键词是否存在，存在则通过get方法获取缓存；如果搜索关键词不存在缓存中则进行搜索，并调用存储策略的set方法将搜索结果缓存。

```typescript
class Search {
  private cacheStrategy: CacheStrategy;

  constructor(cacheStrategy: CacheStrategy) {
    this.cacheStrategy = cacheStrategy;
  }

  search(query: string): void {
    // 检查缓存中是否存在搜索记录
    if (this.cacheStrategy.has(query)) {
      // 从缓存中获取搜索结果
      const results = this.cacheStrategy.getCache(query);
      return results;
    } else {
      // 执行搜索操作，获取搜索结果
      const results = this.performSearch(query);
      // 将搜索结果存储到缓存中
      this.cacheStrategy.setCache(query, results);
      return results;
    }
  }

  private performSearch(query: string): string[] {
    // 模拟搜索操作，返回搜索结果
    return [`Result 1 for ${query}`, `Result 2 for ${query}`, `Result 3 for ${query}`];
  }
}
```

后续实例化搜索类时，可以根据需要传递不同的存储策略。

```typescript
// 实例化使用内存策略的搜索类
const memoryCacheSearch = new Search(new MemoryCacheStrategy());
memoryCacheSearch.search("apple");
memoryCacheSearch.search("banana");
memoryCacheSearch.search("apple"); // 从缓存中获取搜索结果

// 实例化使用 localStorage 策略的搜索类
const localStorageSearch = new Search(new LocalStorageCacheStrategy());
localStorageSearch.search("apple");
localStorageSearch.search("banana");
localStorageSearch.search("apple"); // 从缓存中获取搜索结果
```

这样就将搜索功能和缓存策略隔离开来了，后续想增加IndexedDB存储，只需要新建一个策略即可，搜索类无需任何改动。

我们再看一个前端开发中，非常常见的页签功能实现。

![页签功能](./images/10-策略模式-tab.png)

在上述图中，我们可以通过切换页签查看不同类型的成员，不同成员的表格展示项也不完全相同，每个类型的成员都有删除操作，但是调用的接口不同。

如果没有使用策略模式，我们可能的实现如下（为了更清楚的看到策略模式的结构，我们忽略UI相关的代码，只写核心逻辑）。

```javascript

function getUsers(type){
    if(type === 'ordinaryUser'){
        //获取普通用户数据
    }else if(type === 'vip'){
        //获取Vip用户数据
    }else if(type === 'blackList'){
        //获取黑名单用户数据
    }
}

function deleteUser(type, userInfo){
    if(type === 'ordinaryUser'){
        //调用删除普通用户接口
    }else if(type === 'vip'){
        //调用删除Vip用户接口
    }else if(type === 'blackList'){
        //调用删除黑名单用户接口
    }
}
```
我们经常看到这种丑陋的代码，在多个函数中都进行某种类型判断，然后执行不同逻辑的代码，感觉非常的繁琐，能不能把这些分支判断去掉呢？当然了，我们可以通过策略模式来进行优化。

每个类型的用户策略中可以提供相应的getUsers和deleteUser方法，在业务中根据用户类型动态选择相应的策略，然后调用策略提供的方法。

```javascript
const userStrategy = {
    ordinary: {
        getUsers: function (){},
        deleteUser: function (userInfo){}
    },
    vip: {
        getUsers: function (){},
        deleteUser: function (userInfo){}
    },
    blackList:{
        getUsers: function (){},
        deleteUser: function (userInfo){}
    }
}


function getUsers(type){
    userStrategy[type].getUsers();
}

function deleteUser(type, userInfo){
    userStrategy[type].deleteUser(userInfo);
}
```

可以看到，用策略模式重构后的代码依然十分优雅，不同用户的操作内聚在一起，而且业务代码中消除了类型判断，无论是可读性还是可维护性都大大提升。


## 总结

- 当代码中充斥着大量重复的分支判断的时候，可以考虑试试策略模式
- 策略模式中的每个策略需要遵循相同的接口，策略之间可以互相替换
- 策略模式允许在运行时中动态分配策略
- 策略模式将策略的变化和调用方隔离开来，可以很方便地扩展策略，符合开闭原则
- 策略模式可以提升代码的可读性和可维护性，是一种非常常见的有效的设计模式


# 装饰器模式

装饰器模式，也有人称为装饰者模式，是我们非常常见的一个设计模式。我们先看下装饰器模式的定义

> 装饰器模式是指允许在**不修改现有对象**的情况下，**动态地**向对象添加额外的行为或功能。装饰器模式通过将对象包装在一个装饰器对象中，从而在运行时动态地添加新的行为或修改现有行为。

装饰器模式核心要求是在不修改现有对象（类、函数、组件等）的情况下，扩展对象的行为或功能，很明显，这符合我们前面讲过的一个重要的软件设计原则：开闭原则（对扩展开发，对修改关闭）。

我们通过三个场景来加深对装饰器模式的理解。

## 扩展第三方库方法

假设我们现在想要给第三方库lodash的方法加一个日志功能，即在某个方法被调用之前，将调用信息存储到日志中。

由于lodash是个第三方库，我们并不能修改其源码，此时，可以创建一个日志装饰器，通过拦截lodash的方法调用实现这个需求。

```javascript
function logDecorator(obj, methodName) {
    const originalMethod = obj[methodName];

    obj[methodName] = function (...args) {
        console.log(`${methodName}方法被调用`);
        return originalMethod.apply(this, args);
    };
}

logDecorator(lodash, 'get');
lodash.get({a: 5}, 'a') //这里会打印 get方法被调用
```
这种方式在前端开发中经常会用到，比如在我的开源库 [vue-office](https://github.com/501351981/vue-office) 中就多次使用该方法扩展xSpreadSheet的功能。

```javascript
//监听excel底部页签的切换事件
//在切换事件后刷新页面数据
let swapFunc = xs.bottombar.swapFunc;
xs.bottombar.swapFunc = function (index) {
    swapFunc.call(xs.bottombar, index);
    //刷新页面数据
};
```

## 扩展类

上述示例我感觉并不够经典，不能完全反应装饰器模式的定义，因为装饰器模式中要求不能修改现有对象，在上述示例中，虽然没有修改现有对象所属的Class类，但是修改了对象实例的方法。

我们来看一个更经典的示例。

假设我们有一个简单的购物车对象，包含一个items数组来存储购物车中的商品，拥有一个计算购物车中物品价格的方法 getTotalPrice。
```javascript
class ShoppingCart {
  constructor() {
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
    console.log(`Item added: ${item}`);
  }

  getTotalPrice() {
    return this.items.reduce((total, item) => total + item.price, 0);
  }
}
```

当然了，在购物时计算价格并不是这么简单，比如在有商家打折、优惠券、Vip会员折扣、满减等优惠场景叠加时，价格的计算就会很复杂，如果把所有计算逻辑都放到购物车类中，那么ShoppingCart的实现会非常复杂，这时可以把各种优惠方式做成一个个装饰器，通过嵌套装饰器来完成复杂的逻辑计算。

我们先来实现一个折扣装饰器DiscountDecorator，装饰器的构造参数中包含要装饰的对象，即购物车实例cart。

```javascript
class DiscountDecorator {
  constructor(cart, discount) {
    this.cart = cart;
    this.discount = discount; // 折扣
  }

  //实现购物车的方法
  addItem(item) {
    this.cart.addItem(item);
  }
  
  getTotalPrice() {
    const totalPrice = this.cart.getTotalPrice();
    const discountedPrice = totalPrice * this.discount;
    return discountedPrice;
  }
}
```
在折扣装饰器中实现了购物车对象的全部方法，这样就能在任何使用购物车对象的地方，替换成被折扣装饰器装饰后的对象。

现在，我们可以使用装饰器类来装饰原始的购物车对象：

```javascript
const cart = new ShoppingCart();
const discountCart = new DiscountDecorator(cart, 0.9);

discountCart.addItem({ name: 'Product 1', price: 10 });
discountCart.addItem({ name: 'Product 2', price: 20 });

console.log(discountCart.getTotalPrice()); //（ 10 + 20 ）*0.9 = 27
```

如果还有优惠券功能，我们再实现一个优惠券装饰器 CouponDecorator：

```javascript
class CouponDecorator {
  constructor(cart, coupon) {
    this.cart = cart;
    this.coupon = coupon; // 优惠券金额
  }

  addItem(item) {
    this.cart.addItem(item);
  }

  getTotalPrice() {
    const totalPrice = this.cart.getTotalPrice();
    const totalPriceWithCoupon = totalPrice - this.coupon;
    return totalPriceWithCoupon;
  }
}
```

现在有两个装饰器了，我们可以根据用户下单实际情况组合多种不同的装饰器。

```javascript
const cart = new ShoppingCart();
const discountCart = new DiscountDecorator(cart, 0.9);
const couponCart = new CouponDecorator(discountCart, 5);

couponCart.addItem({ name: 'Product 1', price: 10 });
couponCart.addItem({ name: 'Product 2', price: 20 });

console.log(couponCart.getTotalPrice()); // （10 + 20）* 0.9 - 5 = 22

```

可以看到，通过装饰器模式，我们可以动态地给购物车对象添加多个不同的装饰器，每个装饰器都可以添加不同的行为或功能，但是我们没有修改购物车对象的任何代码。通过这种方式，我们可以灵活地扩展和定制对象的功能，实现更复杂的功能组合。

这里要注意一点，装饰器要实现原有对象的全部方法，确保所有使用被装饰对象的地方，都可以无缝替换为装饰后的对象。


## 扩展组件

装饰器模式同样适用于组件开发。

以Vue组件开发为例，假设我们想在每个表单的底部添加一个提交按钮，在点击提交按钮之后进行表单验证，并在验证失败时显示错误消息。我们可以使用装饰者模式来实现这个需求。

首先，我们创建一个装饰者组件FormValidatorDecorator.vue，它接受一个原始组件作为插槽，并在原始组件的基础上添加额外的行为：

```vue
<template>
  <div class="form-validator-decorator">
    <slot></slot>
    <button @click="handleSubmit">提交</button>
    <div v-if="showError" class="error-message">{{ errorMessage }}</div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      showError: false,
      errorMessage: '',
    };
  },
  methods: {
    handleSubmit() {
      // 进行表单验证
      if (this.validateForm()) {
        // 验证通过，执行原始组件的提交逻辑
        this.$slots.default[0].submitForm();
      } else {
        // 验证失败，显示错误消息
        this.showError = true;
        this.errorMessage = 'Form validation failed';
      }
    },
    validateForm() {
      // 进行表单验证的逻辑，返回验证结果
      return this.$slots.default[0].validate();
    },
  },
};
</script>
```

现在，我们可以使用装饰者组件来装饰原始的表单组件：

```vue
<template>
  <form-validator-decorator>
    <Form></Form>
  </form-validator-decorator>
</template>

<script>
import Form from './Form.vue';
import FormValidatorDecorator from './FormValidatorDecorator.vue';

export default {
  components: {
    Form,
    FormValidatorDecorator,
  },
};
</script>
```

这样，我们就成功地给表单组件添加了一个额外的行为，即表单验证功能。在用户点击提交按钮时，会先进行表单验证，如果验证通过，则执行原始组件的提交逻辑；如果验证失败，则显示错误消息。

通过装饰者模式，我们可以动态地给Vue组件添加多个不同的装饰器，每个装饰器都可以添加不同的行为或样式，而不会影响原始组件的代码。

类似的场景很多，比如给每个组件的右上角增加全屏操作按钮、给图片增加预览按钮或者给组件增加拖拽缩放功能、展开收起功能等，都可以通过装饰器模式进行开发。

```vue

<template>
    <!--全屏装饰器，右上角显示全屏按钮-->
    <full-screen-decorator>
        <!--拖拽缩放缩放装饰器，让组件可以通过拖拽调节宽高-->
        <drag-scale-decorator>
            <!--展开收起装饰器，让组件可以收缩成一个小图标-->
            <collapse-decorator>
                <component/>
            </collapse-decorator>
        </drag-scale-decorator>
    </full-screen-decorator>
</template>
```

通过组合多种装饰器，可以为组件增加各种不同的功能，试想下，如果不采用装饰器模式，如何实现这个功能呢，是不是要封装大量的组件，比如支持全屏的A组件、支持全屏和缩放的A组件、支持缩放和展开收起的B组件、支持全屏和缩放的B组件...这样势必会造成组件数量爆炸，而通过装饰器模式，我们只需要实现有限的几个装饰器，然后通过各种组合，就可以产生支持各种不同行为的新组件。

## 总结

- 装饰器模式设计三个主体：被装饰对象（class、函数、或者组件）、装饰器和装饰后的对象
- 装饰器在不修改被装饰对象的情况下，扩展对象的行为和功能，装饰后的对象支持被装饰对象的所有属性和方法，可以平替被装饰对象
- 通过装饰器模式，可以避免出现对象爆炸现象，通过组合不同功能的装饰器，动态产生新对象
- 装饰器模式符合开闭原则，是实现功能扩展的一个有效的模式




设计模式的一个核心精神：把变化的部分取出来并进行封装，以便以后可以轻易地改动或者扩充此部分，而不影响不需要变化的其他部分。

> 系统中的某部分改变不会影响其他部分